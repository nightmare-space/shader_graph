part of 'package:shader_graph/shader_graph.dart';

/// 输入来自另一个 ShaderBuffer 的输出纹理。
/// Input comes from another ShaderBuffer's output texture.
class ShaderBufferInput extends ShaderInput {
  ShaderBufferInput(
    this.buffer, {
    this.usePreviousFrame = false,
    this.wrap = WrapMode.clamp,
    this.filter = FilterMode.linear,
  });

  final ShaderBuffer buffer;
  final bool usePreviousFrame;
  @override
  final WrapMode wrap;

  @override
  final FilterMode filter;

  /// 对于反馈输入，选择使用上一帧的输出纹理。
  /// For feedback input, choose to use the output texture from the previous frame.
  @override
  ui.Image? resolve() {
    return usePreviousFrame ? buffer._prevOutput : buffer._output;
  }
}

/// 输入来自应用资源包中的图片。
/// Input comes from an image in the app's asset bundle.
class AssetInput extends ShaderInput {
  AssetInput({required this.assetPath, this.wrap = WrapMode.clamp, this.filter = FilterMode.linear});
  ui.Image? image;
  final String assetPath;
  bool _isLoading = false;
  @override
  final WrapMode wrap;

  @override
  final FilterMode filter;

  void loadAssetImage() async {
    final assetImageByteData = await rootBundle.load(assetPath);
    final codec = await ui.instantiateImageCodec(assetImageByteData.buffer.asUint8List());
    image = (await codec.getNextFrame()).image;
    _isLoading = false;
  }

  @override
  ui.Image? resolve() {
    if (image == null && !_isLoading) {
      // 读取图标资源
      // start reading asset from rooutBundle
      _isLoading = true;
      loadAssetImage();
    }
    return image;
  }
}

/// 输入来自键盘控制器生成的键盘纹理。
/// Input comes from a keyboard texture generated by KeyboardController.
class KeyboardInput extends ShaderInput {
  KeyboardInput({this.wrap = WrapMode.clamp, this.filter = FilterMode.linear});

  @override
  final WrapMode wrap;

  @override
  final FilterMode filter;

  ui.Image? Function()? imageProvider;

  @override
  ui.Image? resolve() => imageProvider?.call();
}

/// 空输入，会在 `ShaderBuffer,render` 中用默认的 Image 填充
/// Empty input, will be filled with a default Image in `ShaderBuffer.render`
class EmptyInput extends ShaderInput {
  EmptyInput({this.wrap = WrapMode.clamp, this.filter = FilterMode.linear});

  @override
  final WrapMode wrap;

  @override
  final FilterMode filter;

  @override
  ui.Image? resolve() => null;
}
